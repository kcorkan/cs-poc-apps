<!DOCTYPE html>
<html>
<head>
    <title>PlanningApp</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('Toolbox',{
    singleton: true,

    loadProjects: function(fetchList){
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store',{
            model: 'Project',
            fetch: fetchList,
            limit: 'Infinity'
        }).load({
            callback: function(records, operation){
                deferred.resolve(records);
            }
        });
        return deferred;
    },
    getModelObject: function(name) {
        var deffered=Ext.create('Deft.Deferred');
        Rally.data.ModelFactory.getModel({
            type: name,
            success: function(model) {
                deffered.resolve(model);
            }
        });
        return deffered.promise;
    },
    buildProjectPinBuildingBlockData: function(records, fieldName){
        var hashByObjectID = Toolbox.buildHashByField(records, 'ObjectID'),
            pins = _.map(_.filter(records, function(r){return (/^TECHNOLOGY AREA/).test(r.get('Name')); }),
                function(r){
                    return r.get('ObjectID');
                });

        var projectsWithBuildingBlocks = Ext.Array.filter(records, function(record){
            return record.get(fieldName) && record.get(fieldName).length > 0;
        });

        var data = Ext.Array.map(projectsWithBuildingBlocks, function(p){
            var path = Toolbox.getProjectPath(p, hashByObjectID),
                pathNames = Toolbox.getStringPath(path, hashByObjectID),
                pin = _.intersect(pins, path);

            return {
                Name: p.get('Name'),
                BuildingBlock: p.get(fieldName),
                ObjectID: p.get('ObjectID'),
                Ancestors: path,
                AncestorNames: pathNames,
                Pin: hashByObjectID[pin]
            };
        });
        return data;
    },
    buildHashByField: function(records, field){
        var hash = {};
        Ext.Array.each(records, function(record){
            hash[record.get(field)] = record;
        });
        return hash;
    },
    buildCustomProjectData: function(records,customField){
        var hashByObjectID = Toolbox.buildHashByField(records, 'ObjectID');

        var projectsWithBuildingBlocks = Ext.Array.filter(records, function(record){
            return record.get(customField) && record.get(customField).length > 0;
        });

        var data = Ext.Array.map(projectsWithBuildingBlocks, function(p){
            var path = Toolbox.getProjectPath(p, hashByObjectID),
                stringPath = Toolbox.getStringPath(path, hashByObjectID);
            return {
                Name: p.get('Name'),
                BuildingBlock: p.get(customField),
                ObjectID: p.get('ObjectID'),
                Path: stringPath,
                Ancestors: path
            };
        });
        return data;
    },
    getStringPath: function(path, hashByObjectID){
        var stringPath = _.map(path, function(p){ return hashByObjectID[p].get('Name') || "--"; });
        return stringPath;
    },
    getProjectPath: function(projectRecord, projectHashByObjectID){
        var parent = projectRecord.get('Parent') && projectRecord.get('Parent').ObjectID,
            path = [projectRecord.get('ObjectID')];

        while (parent){
            var parentRecord = projectHashByObjectID[parent];
            if (parentRecord){
                path.unshift(projectHashByObjectID[parent].get('ObjectID'));
                parent = parentRecord.get('Parent') && parentRecord.get('Parent').ObjectID;
            } else {
                parent = null;
            }
        }
        return path;
    }
});
                Ext.define('DemandCalculator',{
    constructor: function(config){
        this.records = config.records;
        this.homePin = config.homePin;
    },
    getHomeDemand: function(quarter){
        return this._getDemand(this.records, quarter, this.homePin);
    },
    getTotalDemand: function(quarter){
        return this._getDemand(this.records, quarter);
    },
    getVisitorDemand: function(quarter){
        return this.getTotalDemand(quarter) - this.getHomeDemand(quarter);
    },
    getHomeDemandFromVisitingTeams: function(quarter){
        //TODO: this is if we eventually want to visualize how much of the home capacity is being requested from Visiting teams
        return 0;
    },
    getHomeDemandFromHomeTeam: function(quarter){
        //TODO: this is if we eventually want to visualize how much of the home capacity is being requested from home teams
        return 0;
    },
    _getDemand: function(records, quarter, homePin){
        var demand = 0;
        Ext.Array.each(records, function(r){
            demand += r.getDemand(quarter,homePin); //If home pin is empty, then it will calculate the total demand
        });
        return demand;
    }
});
                Ext.define('SummaryTemplate',{
    extend: 'Ext.XTemplate',

    width: '100%',
    /**
     * @cfg {String}
     * define a height if necessary to fit where it's being used
     */
    height: '20px',

    constructor: function(config) {
        var templateConfig = [
            '<tpl><table class="summary">',
            '<thead>',
                '<th class="summary">Platform/PIN</th>',
                '<th class="summary">Quarter</th>',
                '<th class="summary">Home Demand</th>',
                '<th class="summary">Team Sprint Capacity</th>',
                '<th class="summary">Utilization</th>',
                '<th class="summary">Visitor Demand</th>',
            '</thead>',
            '<tpl for=".">',
            '<tr>',
                '<td class="summary">{Pin}</td>',
                '<td class="summary">{Quarter}</td>',
                '<td class="summary">{[this.getHomeDemand(values)]}</td>',
                '<td class="summary">{TeamSprintCapacity}</td>',
                '<td class="summary">',
            '<div class="progress-bar-container field-{[this.getPercentUtilization]}" style="{[this.getDimensionStyle()]}">',
            '<div class="rly-progress-bar" style="background-color: {[this.calculateColorFn(values)]}; width: {[this.calculateWidth(values)]}; "></div>',
            '<tpl if="this.showDangerNotificationFn(values)">',
            '<div class="progress-bar-danger-notification"></div>',
            '</tpl>',
            '<div class="progress-bar-label">',
            '{[this.generateLabelTextFn(values)]}',
            '</div>',
            '</div>',
                '</td>',
                '<td class="summary">{[this.getVisitorDemand(values)]}</td>',
            '</tr>',
            '</tpl>',
            '</table></tpl>',
            {
                calculateColorFn: function(recordData){
                    var percentDone = this.getPercentUtilization(recordData);
                    if (percentDone < 80) {
                        return Rally.util.Colors.lime;
                    } else if (recordData.percentDone <= 1) {
                        return Rally.util.Colors.yellow;
                    } else {
                        return Rally.util.Colors.red_med;
                    }
                },
                getVisitorDemand: function(recordData){
                    return (recordData.totalDemand - recordData.homeDemand) || '--';
                },
                getHomeDemand: function(recordData){
                    return (recordData.homeDemand || '--');
                },
                getPercentUtilization: function(recordData){
                    return recordData.totalDemand > 0 ? Math.round(recordData.homeDemand/recordData.TeamSprintCapacity * 100) : 0;
                },
                getDimensionStyle: function(){
                    return 'width: ' + this.width + '; height: ' + this.height + '; line-height: ' + this.height + ';display: inline-block';
                },
                calculateWidth: function (recordData) {
                    var percentDone = this.getPercentUtilization(recordData);
                    return percentDone > 100 ? '100%' : percentDone + '%';
                },
                generateLabelTextFn: function (recordData) {
                    return this.getPercentUtilization(recordData) + '%';
                }
            }
        ];

        return this.callParent(templateConfig);

    }
});
                Ext.define('ProjectInformationStore',{
    buildingBlockField: 'c_BuildingBlock',
    constructor: function(config){
        this.projectHashByObjectID = this.buildHashByField(config.projectRecords, 'ObjectID');
    },
    /**
     * getPinRecordForProject
     * @param projectObjectID
     * @returns {the project record that represents the ancestor PIN for the passed project Object ID}
     * A project is determined as a PIN by it's naming as a "Technology Area: *".  If there are multiple
     * project name matches in the passed project's hierarchy, then the highest level match is return.
     */
    getPinRecordForProject: function(projectObjectID, hash){
        var projectHashByObjectID = hash || this.projectHashByObjectID,
            rec = projectHashByObjectID[projectObjectID];

        if (!rec){
            console.log('null', projectObjectID, this.projectHashByObjectID);
            return null;
        }

        if (rec.get('__pin')){
            return projectHashByObjectID[rec.get('__pin')];
        }

        var path = rec.get('__path') || this.getProjectPath(rec, projectHashByObjectID),
            pinRecord = null,
            pinRegExp = new RegExp("^TECHNOLOGY AREA:","i");

        Ext.Array.each(path, function(p){
            if (pinRegExp.test(projectHashByObjectID[p].get('Name'))){
                pinRecord = projectHashByObjectID[p];
                return false;
            }
        });
        if (pinRecord){
            rec.set('__pin', pinRecord.get('ObjectID'));
        }
        return pinRecord;
    },
    /**
     * getTeamSprintCapacity:  calculates the team sprint capacity for the passed project.
     * For the POC we are just pulling this from a custom field.
     * Other approaches discussed were to count the leaf projects inside of a pin and multiply those
     * by a number
     */
    getTeamSprintCapacity: function(projectOid, quarters){
        return this.getPinRecordForProject(projectOid).get('c_Capacity');
    },
    buildHashByField: function(records, field){
        var hash = {};
        console.log('buildHashByField', records);
        Ext.Array.each(records, function(record){
            hash[record.get(field)] = record;
        }, this);
        this.projectHashByObjectID = hash;

        Ext.Object.each(hash, function(key, record){
            record.set('__path', this.getProjectPath(record, hash));
        }, this);

        return hash;
    },
    /**
     * getProjectPath
     * @param projectRecord
     * @param projectHashByObjectID
     * @returns {*[]} returns an array of project ObjectIDs that represent the hierarchy path for the passed projectRecord
     */
    getProjectPath: function(projectRecord, projectHashByObjectID){
        var parent = projectRecord.get('Parent') && projectRecord.get('Parent').ObjectID,
            path = [projectRecord.get('ObjectID')];

        while (parent){
            var parentRecord = projectHashByObjectID[parent];
            if (parentRecord){
                path.unshift(projectHashByObjectID[parent].get('ObjectID'));
                parent = parentRecord.get('Parent') && parentRecord.get('Parent').ObjectID;
            } else {
                parent = null;
            }
        }
        return path;
    },
    getBuildingBlockOptions: function(projectObjectID, useHomeTeam, hash){

        var homePin = this.getPinRecordForProject(projectObjectID).get('ObjectID'),
            buildingBlockField = this.buildingBlockField;

        if (!hash){
            hash = this.projectHashByObjectID;
        }

        var optionsHash = {};
        Ext.Object.each(hash, function(key, obj){
            var pin = this.getPinRecordForProject(obj.get('ObjectID'), hash) &&
                this.getPinRecordForProject(obj.get('ObjectID'), hash).get('ObjectID'),
                bb = obj.get(buildingBlockField);
            console.log('pin',pin,bb);
            if (bb && pin && ((pin === homePin) === useHomeTeam)){
                if (!optionsHash[pin]){
                    optionsHash[pin] = [];
                }
                if (!Ext.Array.contains(optionsHash[pin], bb)){
                    optionsHash[pin].push(bb);
                }
            }
        }, this);

        var data = [];
        Ext.Object.each(optionsHash, function(key, opt){
            Ext.Array.each(opt, function(bb){
                var name = hash[key].get('Name');
                console.log('jey',key,hash[key],name);
                data.push({
                    pin: key,
                    pinName: name,
                    buildingBlock: bb
                });
            });
        });
        console.log('data',data, optionsHash);
        return data;
    }
});

                Ext.define('BuildingBlock', {
    extend: 'Ext.data.Model',
    fields: ['ordinal', 'team','type','name','amount'],
    belongsTo: 'PortfolioModelWithBuildingBlocks'
});

Ext.define('ExtendedModelBuilder',{
    singleton: true,

    build: function(modelType, newModelName, context) {
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: modelType,
            success: function(model) {

                var default_fields = [{
                    name: 'children',
                    convert: function(value, record){
                        return record._getBuildingBlockObjects();
                    }
                },{
                    name: 'text',
                    convert: function(value, record){
                        return record.get('FormattedID');
                    }
                },{
                    name: '__demand',
                    defaultValue: '--'
                }];
                var new_model = Ext.define(newModelName, {
                    extend: model,
                    fields: default_fields,
                    buildingBlockField: 'c_RequestedPins',
                    /**
                     * appends building block data to the record's building blocks
                     * @param selectedTeams
                     */
                    appendBuildingBlock: function(bbs){
                        var buildingBlocks = this._getBuildingBlockObjects();

                        //If the building block already exists, then it won't be appended.
                        Ext.Array.each(bbs, function(bb){
                            var existingBB = Ext.Array.filter(buildingBlocks, function(b){
                                return b.pin === bb.pin && b.quarter === bb.quarter && b.buildingBlock === bb.buildingBlock;
                            });
                            if (!existingBB || existingBB.length === 0 ){
                                buildingBlocks.push(bb);
                            }
                        });
                        this._setBuildingBlockObjects(buildingBlocks);
                    },
                    getFlattenedBuildingBlockObjects: function(quarters){
                        var buildingBlocks = this._getBuildingBlockObjects(),
                            hash = {};

                        Ext.Array.each(buildingBlocks, function(bb){
                            var key = bb.pin + "|" + bb.buildingBlock;
                            if (!hash[key]){
                                hash[key] = {
                                        pin: bb.pin,
                                        pinName: bb.pinName,
                                        buildingBlock: bb.buildingBlock
                                    };
                                Ext.Array.each(quarters, function(q){
                                    hash[key][q] = 0;
                                });
                            }
                            if (Ext.Array.contains(quarters, bb.quarter)){
                                hash[key][bb.quarter] = bb.demand || 0;
                            }
                        });
                        return _.values(hash);
                    },
                    updateDemand: function(demand, quarter, pin, buildingBlock){
                        var bbs = this._getBuildingBlockObjects(),
                            updatedBuildingBlocks = [];
                        Ext.Array.each(bbs, function(b){
                            if (b.quarter === quarter && b.pin === pin && b.buildingBlock === buildingBlock){
                                b.demand = demand;
                            }
                            updatedBuildingBlocks.push(b);
                        });

                        this._setBuildingBlockObjects(updatedBuildingBlocks);
                    },
                    removeDemand: function(pin, buildingBlock, quarters){
                         var bbs = this._getBuildingBlockObjects(),
                            updatedBuildingBlocks = Ext.Array.filter(bbs, function(b){
                                var match = b.pin === pin && b.buildingBlock === buildingBlock &&
                                        Ext.Array.contains(quarters, b.quarter);
                                return !match;
                            });
                        this._setBuildingBlockObjects(updatedBuildingBlocks);
                    },
                    /**
                     * private functions to encode and decode the JSON that is stored in the text field or external data source
                     *
                     * @returns {*}
                     * @private
                     *
                     * Expected JSON format:
                     *  [{
                     *      pin: <project ObjectID of assigned pin>,
                     *      pinName: <project Name of assigned pin>,
                     *      buildingBlock: <building block name>,
                     *      quarter: <quarter name>,
                     *      demand: <demand>
                     *   },{
                     *      ...
                     *   }]
                     *
                     */
                    _getBuildingBlockObjects: function(){
                        var objects =  Ext.JSON.decode(this.get(this.buildingBlockField) || "[]");

                        //post-load data manipulation  here, if needed.

                        return objects;
                    },
                    _setBuildingBlockObjects: function(buildingBlocks){

                        //pre-save data manipulation here - need to transform the flattened rows into
                        //normalized object to save as JSON, if needed.

                        this.set(this.buildingBlockField, Ext.JSON.encode(buildingBlocks || []));
                        this.save();
                    },
                    /**
                     * updateBuildingBlocks updates the building blocks to either the internal text field
                     * or eventually to an external data source
                     * @param bbs
                     *
                     * In this method we need to:
                     *   -- not overwrite building blocks that aren't in the quarters we are interested in
                     *   -- remove building blocks that we may have deleted from the UI
                     *   -- add building blocks that we may have added to the UI
                     */
                    updateBuildingBlocks: function(bbs){
                        //For this function, we need to make sure we:
                        //  --> don't overwrite any building blocks in other quarters and
                        this._setBuildingBlockObjects(bbs);
                    },
                    getDemand: function(quarter, pin){
                        var buildingBlocks = this._getBuildingBlockObjects(),
                            demand = 0;

                        Ext.Array.each(buildingBlocks, function(bb){
                            if (bb.quarter === quarter){
                                if (pin){
                                    if (Number(bb.pin) === pin) {
                                        demand += bb.demand;
                                    }
                                } else {
                                    demand += bb.demand;
                                }
                            }
                        });
                        return demand;
                    }

                });
                deferred.resolve(new_model);
            },
            save: function(options){
                //add any pre save manipulations here
                return callParent(options);
            }
        });
        return deferred;
    }
});
                Ext.define('BuildingBlockComponent', {
    extend: 'Ext.container.Container',
    alias: 'widget.buildingblockcomponent',

    layout: {
        type: 'vbox',
        align: 'stretch',
        style: {
            backgroundColor: Rally.util.Colors.grey1
        }
    },

    defaults: {
        flex: 1
    },

    /**
     * @constructor
     * @param {Object} config
     */
    constructor: function (config) {
        this.mergeConfig(config);
        this.callParent([config]);
    },

    initComponent: function () {
        var record = this.record,
            quarters = this.quarters,
            bb = this.record.getFlattenedBuildingBlockObjects(quarters);

        var items = _.map(bb, function(b){

            var subItems = [{
                xtype: 'container',
                flex: 1
            },{
                xtype: 'rallybutton',
                cls: 'rly-small secondary',
                iconCls: 'icon-delete',
                handler: function(){
                    record.removeDemand(b.pin, b.buildingBlock, quarters);
                }
            },{
                xtype: 'container',
                data: b,
                tpl: '<tpl>{pinName} - {buildingBlock}</tpl>',
                flex: 2,
                height: 25,
                cls: 'buildingBlockLabel',
                margin: 5
            }];
            Ext.Array.each(quarters, function(q){

                subItems.push({
                    xtype: 'rallynumberfield',
                    value: b[q],
                    margin: 10,
                    flex: 1,
                    buildingBlock: b,
                    quarter: q,
                    listeners: {
                        blur: function(nb){
                            record.updateDemand(nb.getValue(), q, b.pin, b.buildingBlock);
                        },
                        scope: this
                    }
                });
            });
            subItems.push({
                xtype: 'container',
                flex: 3
            });

            return {
                xtype: 'container',
                layout: 'hbox',
                items: subItems
            };
        }, this);

        this.items = items;
        this.setHeight(35 * bb.length);

        this.callParent(arguments);
    }

});
                var data = [];
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',

    parentTypePath: 'portfolioitem/roadmap',
    planningQuarterField: 'c_PlanningQuarter',
    parentFetch: ['FormattedID','Name','ObjectID','Project','c_RequestedPins'],
    projectFetchList: ['ObjectID','Name','Parent'],
    buildingBlockField: 'c_BuildingBlock',
    teamCapacityField: 'c_Capacity',

    items: [{
        xtype:'container',
        itemId: 'filterBox',
        layout: 'hbox',
        padding: 10
    },{
        xtype: 'container',
        itemId: 'summaryBox',
        padding: 10
    },{
        xtype:'container',
        itemId: 'gridBox',
        padding: 10
    }],

    launch: function() {

        var projectFetchList = this.projectFetchList.concat([this.buildingBlockField, this.teamCapacityField]);

        Deft.Promise.all([
            Toolbox.loadProjects(projectFetchList)
        ]).then({
            scope:this,
            success: function(results) {
                 this.projectInfoStore =Ext.create('ProjectInformationStore',{
                    projectRecords: results[0]
                });
                this._addComponents();
            },
            failure: function(message) {
                Rally.ui.notify.Notifier.showError({message: 'Error retrieving projects: ' + message});
            }
        });
    },

    _addComponents: function() {

        this.down('#filterBox').removeAll();

        //validate that we are running within the scope of a PIN.
        if (!this._getPlatformPin()){
            console.log('this', this._getPlatformPin());
            this.down('#filterBox').add({
                xtype: 'container',
                html: "Please choose a Project Scope that is associated with a valid PIN."
            });
            return;
        }

        this._addFilterComponent();
        this._addSummaryComponent();
    },
    _addSummaryComponent: function() {
        this.down('#summaryBox').tpl = Ext.create('SummaryTemplate');
        this._updateSummaryContainer();
    },
    _updateSummaryContainer: function(){

        var summary = this.down('#summaryBox'),
            projectID = this.getContext().getProject().ObjectID,
            quarters = this._getQuarters();

        var summaryInfo = [];
        Ext.Array.each(quarters, function(q){

            summaryInfo.push({
                Pin: this._getPlatformPinName(),
                Quarter: q,
                TeamSprintCapacity: this.projectInfoStore.getTeamSprintCapacity(projectID),
                homeDemand: this.demandCalculator && this.demandCalculator.getHomeDemand(q) || 0,
                totalDemand: this.demandCalculator && this.demandCalculator.getTotalDemand(q) || 0
            });
        }, this);

        if (quarters.length === 0){
            summaryInfo.push({
                Pin: this._getPlatformPinName(),
                Quarter: '<div style="color:red;">Please select at least 1 quarter to plan</div>',
                TeamSprintCapacity: '--',
                homeDemand: '--',
                totalDemand: '--'
            });
        }

        summary.update(summaryInfo);
    },

    _getPlatformPin: function(){
        return this.projectInfoStore.getPinRecordForProject(this.getContext().getProject().ObjectID);
    },
    _getPlatformPinName: function(){
        var pin = this._getPlatformPin();
        return pin && pin.get('Name') || "No PIN";
    },
    _getPlatformPinObjectID: function(){
        var pin = this._getPlatformPin();
        return pin && pin.get('ObjectID') || 0;
    },
    _addFilterComponent: function() {

       this.down('#filterBox').add({
                xtype: 'rallyfieldvaluecombobox',
                itemId: 'quarterComboBox',
                fieldLabel: 'Planning Quarter:',
                labelAlign: 'right',
                allowNoEntry: false,
                model: this.parentTypePath,
                field: this.planningQuarterField,
                multiSelect: true,
                allowBlank: false
        });

        this.down('#filterBox').add({
            xtype: 'rallycheckboxfield',
            fieldLabel: 'View Visitor Requests',
            value: false,
            itemId: 'showVisitingRequests',
            labelAlign: 'right',
            labelWidth: 150
        });

        this.down('#showVisitingRequests').on('change', this._updateDisplay, this);
        this.down('#quarterComboBox').on('select', this._updateDisplay, this);

        this._updateDisplay();
    },
    /**
     * _getFilters - filters the data (on the server) before it is returned.
     * We are using Context: Project = null becuase we always need to return all demand for the current pin,
     * even if it is not in scope.
     *
     * This function will return ALL the data we need for the filtering and calculations on this page, so we are only loading it
     * when the project changes.
     *
     * @returns {*}
     * @private
     */
    _getFilters: function(){
        var quarters = this._getQuarters(),
            filters = [];

        //if (quarters && quarters.length > 0){ //We have validated that quarters are selected, so we should always have quarters
        //
        //    //TODO: change this depending on how we want to filter quarters (by PlannedStart or PlannedEndDates or by planning field)
        //    Ext.Array.each(quarters, function(q){
        //        if (q && q.length > 0){
        //            filters.push(Ext.create('Rally.data.wsapi.Filter', {
        //                property: this.planningQuarterField,
        //                value: q || ""
        //            }));
        //        }
        //    }, this);
        //}

        var pin = this._getPlatformPinObjectID();

        filters.push ({
            property: 'c_RequestedPins',
            operator: 'contains',
            value: '"' + pin + '"'
        });

        return Rally.data.wsapi.Filter.or(filters);
    },
    _getQuarters: function(){
        return Ext.Array.filter(this.down('#quarterComboBox').getValue() || [], function(q){
            return q && q.length > 0;
        });
    },
    _validateSelections: function(){
         if (this._getQuarters().length > 0){
            return true;
        }

        this._updateSummaryContainer("Please select at least 1 quarter to plan.");
        return false;
    },

    _updateDisplay: function(){

        this.down('#gridBox').removeAll();

        if (!this._validateSelections()){
            return;
        }

        //Now build the model and start loading data
        ExtendedModelBuilder.build(this.parentTypePath, 'PortfolioItemWithBuildingBlocks').then({
            success: this._buildGrid,
            failure: this._showError,
            scope: this
        });
    },
    _getShowVisitingDemand: function(){
        return this.down('#showVisitingRequests') && this.down('#showVisitingRequests').getValue() || false;
    },
    _showError: function(message){
        Rally.ui.notify.Notifier.showError({message: message});
    },
    /**
     * _postProcessData includes:
     *     -- loading external data (if it is being stored externally)
     *     -- filtering data locally (if scoped to show visiting pins as well
     *    applying other local filters (note that we still need to rollup all demand for the current
     *    pin, which is why we need to filter locally
     * @param store
     * @param records
     * @private
     */
    _postProcessData: function(store, records, operation){
        this.demandCalculator = Ext.create('DemandCalculator', {
            records: records, //We want to assign this before we filter so we have access to the entire loaded data set regardless of what was filtered locally.
            homePin: this._getPlatformPinObjectID()
        });

        this.down('#dataGrid').getStore().filterBy(this._filterDisplayData, this);
    },
    /**
     * _filterDisplayData - if show visiting demand, filter pins for visiting teams only.
     * otherwise, filter out all items that are not in this pin that do not use the current pin.
     *
     * If we add other filters (e.g. State), then those need to be filtered here becuase we still need the current demand
     *
     * NOTE:  This is just filtering for display, not for demand calculation, which requires all of the data that was returned.
     * @param item
     * @returns {boolean}
     * @private
     */
    _filterDisplayData: function(item){
        var thisProjectPin = this._getPlatformPinObjectID(),
            pinRegExp = new RegExp('\"' + thisProjectPin + '\"');
        if (this._getShowVisitingDemand()){
            return item.get('Project').ObjectID !== thisProjectPin &&
                pinRegExp.test(item.get('c_RequestedPins'));
        }
        return this.projectInfoStore.getPinRecordForProject(item.get('Project').ObjectID).get('ObjectID') === thisProjectPin ;
    },
    _buildGrid: function(model){

        var grid = this.down('#gridBox').add({
            xtype: 'rallygrid',
            itemId: 'dataGrid',
            stateful: false,
            storeConfig: {
                model: model,
                fetch: this.parentFetch,
                filters: this._getFilters(),
                listeners: {
                    load: this._postProcessData,
                    datachanged: this._updateSummaryContainer,
                    scope: this
                },
                context: {
                    project: null  // We will always need to load all data for the demand, even when we aren't viewing visitor teams so this needs to be null
                }
            },
            margin: 25,
            columnCfgs: this._getColumnCfgs(),
            showRowActionsColumn: false,
            plugins: [{
                ptype: 'rowexpander',
                rowBodyTpl: '<div id="planning-{FormattedID}"></div>'
            }]
        });

        grid.on('afterlayout', this._restoreRowHeight, this);
        grid.getView().on('expandbody', this._expandRowBody, this);
        grid.getView().on('collapsebody', this._collapseRowBody, this);
    },
    /**
     * addresses the issue where the row height gets reset and hides any currently expanded rows
     * @private
     */
    _restoreRowHeight: function(grid){
         Ext.Array.each(grid.getView().getNodes(), function(n){
             var collapsed = /x-grid-row-collapsed/.test(n.className);
             if (!collapsed){
                 //we need to re-expand the expander so that the height gets reset.  There may be a more elegant way to do this, but it needs to be researched.
                 var recordIndex = document.getElementById(n.id) &&
                                    document.getElementById(n.id).dataset &&
                                    document.getElementById(n.id).dataset.recordindex,

                     record = recordIndex ? grid.getStore().getAt(recordIndex) : null;

                 if (record){
                     this._collapseRowBody(n, record);
                     this._expandRowBody(n,record, n);
                 }
             }
        }, this);
    },
    _collapseRowBody: function(rowNode, record, expandRow, options){
        var ctCmp = Ext.getCmp(this._getBuildingBlockCmpId(record));

        if (ctCmp){
            ctCmp.destroy();
        }
    },
    _getBuildingBlockCmpId: function(record){
        return 'buildingBlock-' + record.get('FormattedID');
    },
    _expandRowBody: function(rowNode, record, expandRow, options){
        var quarters = this._getQuarters(),
            ctId = '#planning-' + record.get('FormattedID'),
            ct = Ext.get(expandRow.querySelector(ctId));

        var bbct = Ext.create('BuildingBlockComponent',{
            id: this._getBuildingBlockCmpId(record),
            record: record,
            quarters: quarters,
            renderTo: ct
        });
        ct.setHeight(bbct.getHeight());
    },
    _getColumnCfgs: function(){
        var me = this,
            quarters = this._getQuarters(),
            homePin = this._getPlatformPinObjectID();

        var columns = [{
            xtype: 'rallyrowactioncolumn',
            rowActionsFn: function (record) {
                return [
                    {
                        xtype: 'rallyrecordmenuitem',
                        record: record,
                        text: "Add Home Building Block...",
                        handler: function () {
                            me._showBuildingBlockPicker(true, record);
                        },
                        scope: this
                    },
                    {
                        xtype: 'rallyrecordmenuitem',
                        record: record,
                        text: "Add Visitor Building Block...",
                        handler: function () {
                            me._showBuildingBlockPicker(false, record);
                        },
                        scope: this
                    }
                ];
            }
        },{
            dataIndex: 'FormattedID'
        },{
            dataIndex: 'Name',
            flex: 2
        }];

        quarters = quarters || [];
        Ext.Array.each(quarters, function(q){
            if (q && q.length > 0){
                columns.push({
                    dataIndex: '__demand',
                    text: q + ' Demand (Home / Visiting)',
                    flex: 1,
                    renderer: function(v,m,r) {
                        var home = r.getDemand(q,homePin),
                            total = r.getDemand(q);

                        return Ext.String.format('{0} / {1}', home, total-home);
                    }
                });
            }
        });

        columns = columns.concat([{
           dataIndex: 'Project',
            flex: 1
        },{
           dataIndex: 'PlannedStartDate',
            flex: 1
        },{
           dataIndex: 'PlannedEndDate',
            flex: 1
        }]);
        return columns;
    },
    _showBuildingBlockPicker: function(isHome, record){

        var projectObjectID = this.getContext().getProject().ObjectID,
            teamFields = ['buildingBlock','pinName','pin'],
            teamData = this.projectInfoStore.getBuildingBlockOptions(projectObjectID, isHome);

        var dlg = Ext.create('Rally.ui.dialog.CustomChooserDialog',{
            teamFields: teamFields,
            teamData: teamData,
            listeners: {
                scope: this,
                itemchosen: function(dlg, selectedTeam){

                    if (!Ext.isArray(selectedTeam)){
                        selectedTeam = [selectedTeam];
                    }

                    var data = [],
                        quarters = this._getQuarters();

                    Ext.Array.each(quarters, function(q){
                        Ext.Array.each(selectedTeam, function(t){
                            var tData = t.getData();
                            data.push({
                                pin: tData.pin,
                                pinName: tData.pinName,
                                buildingBlock: tData.buildingBlock,
                                quarter: q,
                                demand: 0
                            });
                        });
                    });
                    record.appendBuildingBlock(data);
                }
            }
        });
        dlg.show();
    }
});

                //USAGE:
//
// teamData is an array of objects with relevant data attributes (one must be a unique ObjectID)
// teamFields is an array of string fields to display in the grid
//
//
//var dlg = Ext.create('Rally.ui.dialog.CustomChooserDialog',{
//    teamFields: fields,
//    teamData: data,
//    listeners: {
//        itemchosen: function(dlg, selectedTeam){
//            console.log('team chosen', selectedTeam);
//        }
//    }
//});
//dlg.show();

Ext.define('Rally.ui.dialog.CustomChooserDialog', {
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.customchooserdialog',

    height: 400,
    width: 600,
    layout: 'fit',
    closable: true,
    draggable: true,

    config: {
        /**
         * @cfg {String}
         * Title to give to the dialog
         */
        title: 'Choose an Item',

        /*
         * teamData is an array of objects with relevant data.  At least one of hte properties must be a unique object id
         *
         */
        teamData: [],
        /*
         * teamFields is the fields to display
         */
        teamFields: [],

        /**
         * @cfg {Boolean}
         * Allow multiple selection or not
         */
        multiple: true,

        /**
         * @cfg {Ext.grid.Column}
         * List of columns that will be used in the chooser
         */
        columns: [
            {
                text: 'Building Block',
                dataIndex: 'buildingBlock',
                flex: 1,
                renderer: function(v,m,r){
                    return r.get('pinName') + ' - ' + r.get('buildingBlock');
                }
            }
        ],

        /**
         * @cfg {String}
         * Text to be displayed on the button when selection is complete
         */
        selectionButtonText: 'Done',

        /**
         * @cfg {Object}
         * The grid configuration to be used when creative the grid of items in the dialog
         */
        gridConfig: {},

        /**
         * @deprecated
         * @cfg {String}
         * The ref of a record to select when the chooser loads
         * Use selectedRecords instead
         */
        selectedRef: undefined,

        /**
         * @cfg {String}|{String[]}
         * The ref(s) of items which should be selected when the chooser loads
         */
        selectedRecords: undefined,

        /**
         * @cfg {Array}
         * The records to select when the chooser loads
         */
        initialSelectedRecords: undefined,

        /**
         * @private
         * @cfg userAction {String} (Optional)
         * The client metrics action to record when the user makes a selection and clicks done
         */

        /**
         * @cfg showRadioButtons {Boolean}
         */
        showRadioButtons: true
    },

    constructor: function(config) {
        this.mergeConfig(config);

        this.callParent([this.config]);
    },

    selectionCache: [],

    initComponent: function() {
        this.callParent(arguments);

        this.addEvents(
            /**
             * @event artifactchosen
             * Fires when user clicks done after choosing an artifact
             * @param {Rally.ui.dialog.ArtifactChooserDialog} source the dialog
             * @param {Rally.data.wsapi.Model}| {Rally.data.wsapi.Model[]} selection selected record or an array of selected records if multiple is true
             */
            'itemchosen'
        );

        this.addCls(['chooserDialog', 'chooser-dialog']);
    },

    destroy: function() {
        this._destroyTooltip();
        this.callParent(arguments);
    },

    beforeRender: function() {
        this.callParent(arguments);

        this.addDocked({
            xtype: 'toolbar',
            dock: 'bottom',
            padding: '0 0 10 0',
            layout: {
                type: 'hbox',
                pack: 'center'
            },
            ui: 'footer',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'doneButton',
                    text: this.selectionButtonText,
                    cls: 'primary rly-small',
                    scope: this,
                    disabled: true,
                    userAction: 'clicked done in dialog',
                    handler: function() {
                        this.fireEvent('itemchosen', this, this.getSelectedRecords());
                        this.close();
                    }
                },
                {
                    xtype: 'rallybutton',
                    text: 'Cancel',
                    cls: 'secondary rly-small',
                    handler: this.close,
                    scope: this,
                    ui: 'link'
                }
            ]
        });

        if (this.introText) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                html: this.introText
            });
        }

        this.addDocked({
            xtype: 'toolbar',
            itemId: 'searchBar',
            dock: 'top',
            border: false,
            padding: '0 0 10px 0',
            items: this.getSearchBarItems()
        });

        this.buildGrid();

        this.selectionCache = this.getInitialSelectedRecords() || [];
    },

    /**
     * Get the records currently selected in the dialog
     * {Rally.data.Model}|{Rally.data.Model[]}
     */
    getSelectedRecords: function() {
        return this.multiple ? this.selectionCache : this.selectionCache[0];
    },

    getSearchBarItems: function() {
        return [
            {
                xtype: 'triggerfield',
                cls: 'rui-triggerfield chooser-search-terms',
                emptyText: 'Search Keyword or ID',
                enableKeyEvents: true,
                flex: 1,
                itemId: 'searchTerms',
                listeners: {
                    keyup: function (textField, event) {
                        if (event.getKey() === Ext.EventObject.ENTER) {
                            this._search();
                        }
                    },
                    afterrender: function (field) {
                        field.focus();
                    },
                    scope: this
                },
                triggerBaseCls: 'icon-search chooser-search-icon'
            }
        ];
    },

    getStoreFilters: function() {
        return [];
    },

    _getProjectDataStore: function(){
        console.log('this',this.teamData, this.teamFields);
        var data = this.teamData;
        return Ext.create('Rally.data.custom.Store',{
            data: data,
            fields: this.teamFields,
            pageSize: data.length,
            remoteFilter: false //we need this for the filtering
        });
    },

    buildGrid: function() {
        if (this.grid) {
            this.grid.destroy();
        }

        var projectDataStore = this._getProjectDataStore();

        var selectionConfig = {
            mode: this.multiple ? 'SIMPLE' : 'SINGLE',
            allowDeselect: true
        };
        this.grid = Ext.create('Rally.ui.grid.Grid', Ext.Object.merge({
            columnCfgs: this.columns,
            enableEditing: false,
            enableColumnHide: false,
            enableColumnMove: false,
            selModel: this.showRadioButtons || this.multiple ? Ext.create('Rally.ui.selection.CheckboxModel', Ext.apply(selectionConfig, {
                enableKeyNav: false,
                isRowSelectable: function (record) {
                    return true;
                }
            })) : Ext.create('Ext.selection.RowModel', selectionConfig),
            showRowActionsColumn: false,
            store: projectDataStore,
            viewConfig: {
                emptyText: Rally.ui.EmptyTextFactory.get('defaultText'),
                publishLoadMessages: false,
                getRowClass: function (record) {
                    return Rally.util.Test.toBrowserTestCssClass('row', record.getId());
                }
            }
        }, this.config.gridConfig));
        this.mon(this.grid, {
            beforeselect: this._onGridSelect,
            beforedeselect: this._onGridDeselect,
            load: this._onGridLoad,
            scope: this
        });
        this.add(this.grid);
        this._onGridReady();
    },

    _addTooltip: function() {
        this._destroyTooltip();
        this.tooltip = Ext.create('Rally.ui.tooltip.ToolTip', {
            target: this.grid.getEl(),
            html: 'You don\'t have permission to edit this item.',
            delegate: '.disabled-row',
            anchor: 'top',
            showDelay: 0,
            showOnClick: true
        });
    },

    _destroyTooltip: function() {
        if (this.tooltip) {
            this.tooltip.destroy();
        }
    },

    _getStoreConfig: function() {
        var storeConfig = _.cloneDeep(this.getInitialConfig().storeConfig);

        if (this._getSearchTerms()) {
            storeConfig.search = this._getSearchTerms();
        }

        storeConfig.filters = (storeConfig.filters || []).concat(this.getStoreFilters());

        return storeConfig;
    },

    _enableDoneButton: function() {
        this.down('#doneButton').setDisabled(this.selectionCache.length ? false : true);
    },

    _findRecordInSelectionCache: function(record){
        return _.findIndex(this.selectionCache, function(cachedRecord) {
            return cachedRecord.get('pin') === record.get('pin') &&
                cachedRecord.get('buildingBlock') === record.get('buildingBlock');
        });
    },

    _onGridSelect: function(selectionModel, record) {

        var index = this._findRecordInSelectionCache(record);
        if (index === -1) {
            if (!this.multiple) {
                this.selectionCache = [];
            }
            this.selectionCache.push(record);
        }
        this._enableDoneButton();
    },

    _onGridDeselect: function(selectionModel, record) {
        var index = this._findRecordInSelectionCache(record);
        if (index !== -1) {
            this.selectionCache.splice(index, 1);
        }

        this._enableDoneButton();
    },

    _onGridReady: function() {
        if (!this.grid.rendered) {
            this.mon(this.grid, 'afterrender', this._onGridReady, this, {single: true});
            return;
        }

        if (this.grid.getStore().isLoading()) {
            this.mon(this.grid, 'load', this._onGridReady, this, {single: true});
            return;
        }

        this._onGridLoad();
        this.center();
    },

    _isArtifactEditable: function(record) {
        return Rally.environment.getContext().getPermissions().isProjectEditor(record.get('Project'));
    },

    _onGridLoad: function() {
        var defaultSelection = Ext.Array.from(this.selectedRef || this.selectedRecords);
        if (defaultSelection.length) {
            var selectedRecords = _.compact(_.map(defaultSelection, function(ref) {
                var recordIndex = this.grid.getStore().find('_ref', ref);
                return recordIndex >= 0 ? this.grid.getStore().getAt(recordIndex) : null;
            }, this));
            if(selectedRecords.length) {
                this.grid.getSelectionModel().select(selectedRecords);
            }
        } else {
            var store = this.grid.store;
            var records = [];

            _.each(this.selectionCache, function(record) {
                var recordIndex = store.find('_ref', record.get('_ref'));

                if (recordIndex !== -1) {
                    var storeRecord = store.getAt(recordIndex);
                    records.push(storeRecord);
                }
            });

            if (records.length) {
                this.grid.getSelectionModel().select(records);
            }
        }

        this._addTooltip();
        if (Rally.BrowserTest) {
            Rally.BrowserTest.publishComponentReady(this);
        }
    },

    _search: function() {
        var terms = new RegExp(this._getSearchTerms(), "gi");
        this.grid.getStore().filterBy(function(record){

            if (!terms){
                return true;
            }

            return terms.test(record.get('Name')) ||
                terms.test(record.get('Path')) ||
                terms.test(record.get('c_BuildingBlock'));
        });
    },

    _getSearchTerms: function() {
        var textBox = this.down('#searchTerms');
        return textBox && textBox.getValue();
    }
});


            Rally.launchApp('CustomApp', {
                name:"PlanningApp",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}
th.summary {
  text-transform: uppercase;
  font-family: ProximaNovaSemiBold,Helvetica,Arial;
  background-color: #e6e6e6;
  font-size: 10pt;
  width: 15%;
}
td.summary {
  font-family: ProximaNova,Helvetica,Arial;
  font-size: 10pt;
  width: 15%;
}
table.summary {
  cellpadding: 10px;
  text-align: center;
}
.x-grid-row-selected .x-grid-td {
  background-color: white;
}
.x-grid-row-highlighted .x-grid-td {
  background-color: white;
}
.buildingBlockLabel {
  font-family: ProximaNova,Helvetica,Arial;
  font-size: 9pt;
}

    </style>
</head>
<body>
</body>
</html>
